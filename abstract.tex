%% -*- mode: latex -*-

\begin{abstract}
  While Emacs proponents largely agree that it is the world's greatest text
  editor, it is almost as much a Lisp machine disguised as an editor.
  Indeed, one of its chief appeals is that it is \emph{programmable} via
  its own programming language, \Elisp{} (or Emacs Lisp), a Lisp in the classic
  tradition.  Its core has remained remarkably stable since its
  inception in 1981, in large part to preserve compatibility with the many
  third-party packages providing a multitude of extensions.
  Still, \Elisp{} has evolved and continues to do so.

  Despite the fact that it is closely tied to a concrete editor, \Elisp{} has
  spawned multiple implementations---in Emacs itself but also in variants of
  Emacs, such as XEmacs and Edwin.  Through competing implementations as
  well as changes in maintainership, it has picked up outside influences
  over the years, most notably from Common Lisp.

  We discuss how important aspects of \Elisp{} have been shaped by
  concrete \emph{requirements} of the editor it supports, such as
  the \textit{buffer-local variables} that tie bindings to
  editor buffers, as well as implementation constraints.
  These requirements led to the choice of a Lisp dialect as Emacs's
  language in the first place, specifically its simplicity and dynamic nature:
  Loading additional Emacs packages or changing the ones in place
  occurs frequently, and having to restart the editor in order to
  re-compile or re-link the code would be unacceptable.  Fulfilling
  this requirement in a more static language would have been difficult
  at best.

  Many extension and configuration languages start out ``small,'' with
  no ambition to grow into a full-fledged programming language.  In
  particular, Emacs's predecessors, Gosling Emacs and TECO featured
  small languages that were too weak to support the vision Richard
  Stallman had for Emacs.  Consequently, Stallman took inspiration
  from Maclisp, and \Elisp{} started as a real programming language
  with powerful abstraction facilities, thus foregoing Greenspun's
  tenth rule.

  One of Lisp's chief characteristics is its malleability through its
  uniform syntax and the use of macros.  This has allowed the language to
  evolve much more rapidly and substantively than the evolution of its core
  would suggest, by letting Emacs packages provide new
  surface syntax.  In particular, \Elisp{} can be customized to look
  much like Common Lisp, and additional packages provide multiple-dispatch
  object systems, legible regular expressions, programmable pattern matching
  constructs, generalized variables, and more.
  Still, the core has also evolved, albeit slowly.  Most notably, it
  acquired lexical scoping through the involvement of
  programming-language researchers with Emacs maintainership.
  
  One area where, maybe surprisingly, \Elisp{} has not picked up
  ``principled design concepts'' is support for some kind of module system,
  despite the fact that
  Emacs constitutes a fairly large ecosystem of independent packages which
  total several million lines of code.  Instead, \Elisp{} relies on social
  mechanisms to achieve composability of packages.  This, combined
  with \Elisp's dynamic nature, have produced a remarkably robust
  system that continues to function even in the face of unexpected
  exceptions.

  While we highlight these technical aspects of \Elisp{} as well as the
  underlying motivations for the various design decisions, we trace
  its development chronologically. The timeline of \Elisp{}
  development is closely tied to the projects and people who have
  shaped it over the years: We document \Elisp{} history through its
  predecessors, Mocklisp and MacLisp, its early development up to the
  ``Emacs schism'' and the fork of Lucid Emacs, the development of
  XEmacs, and the subsequent rennaissance of Emacs development.  When
  it makes sense, we tie in with the evolution of Lisp in general.
\end{abstract}
